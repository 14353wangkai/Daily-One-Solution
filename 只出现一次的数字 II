
- 问题描述

  给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

  

- 问题分析

  有三种解法：

  1. 第一种是利用哈希表存储每个数出现的次数，最后遍历一次哈希表取到所求的值。时间复杂度和空间复杂度皆为：O(n)。
  2. 第二种是先对数组进行排序，接着遍历一次数组，当某个位置的数的下一个位置的数与其相等时，跳三个位置，再判断；若该位置为最后，或者该位置的下一个数与其不等，则是我们所求的值。时间复杂度为：O(nlogn)，空间·复杂度为：O(1)。
  3. 第三种是位运算。已知数组元素皆为整数，则不超过32位，那么统计每位的0、1之和，对3取余，结果则为所求值该位的值。时间复杂度：O(nlogC)，空间复杂度为：O(1)。



- 问题解答

  ```c++
  class Solution {
  public:
      int singleNumber(vector<int>& nums) {
          int ans = 0;
          for(int i = 0; i < 32; i ++){
              int total = 0;
              for (int num : nums) {
                  total += (num >> i) & 1;
              }
              total = total % 3;
              ans |= (total << i);
          }
          return ans;
      }
  };
  ```


# [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/) - wk

- 问题描述

  > 给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。
  >
  > ```
  > 输入：nums = [2,2,3,2]
  > 输出：3
  > ```

- 问题分析
  - 某个元素出现y次，其他元素出现x次，且 `y % x !=0`，这种题的统一做法（不一定是最佳做法）都是统计所有数字的**每一位出现的次数**，那么问题就是如何统计了
  - 所以外层循环就是遍历0~32位(int类型)，内层循环就是遍历每个数字，此时通过一个计数器`cnt`对对应bit位出现的次数进行统计：
    - 在内层循环中，每次都要取出对应位，如果当前位置是0，那么就不加，如果是1，那么`cnt+=1`
    - 如果统计完成之后，发现`cnt % x != 0`，说明出现`y`次的数据当前bit位的值是1，那么就用一个值`res`来统计，即`res |= (1<<i)`

- 问题代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int i = 0;i < 32; ++i) {
            int tot = 0;
            for (int num:nums) {
                tot += ((num >> i) & 1);
            }
            if (tot % 3 != 0) {
                res |= (1 << i);
            }
        }
        return res;
    }   
}
```
