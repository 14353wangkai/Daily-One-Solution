# 整数反转

- 问题描述

  给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

  如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

  假设环境不允许存储 64 位整数（有符号或无符号）。

  

- 问题分析

  反转整数的要点在于：获取这个整数的末尾数字，即可以通过模运算得到，接着再每次将该数除以10。由于整数可能为正也可能为负，因此循环的条件应设为：x != 0。

  本题的难点在于反转后溢出的判断，最大的整数为：2147283647，最小的整数为：-2147483648；可知，当反转的整数达到“214728365”时，若其仍未跳出循环，则必然大于最大整数；同理，当反转的整数达到“-214728365”时，若其仍未跳出循环，则必然小于最小整数；而由于如果原始整数的位数刚好等于最大整数的位数，其初始为只能为1或者2，必定小于7，因此判断是否溢出最大整数可设为：“num > INT_MAX/10”而最小整数可设为“num < INT_MIN/10”

  

- 问题解答

  ```c++
  class Solution {
  public:
      int reverse(int x) {
          int num = 0;
          while (x != 0) {
              if (num > INT_MAX/10 || num < INT_MIN/10)
                  return 0;
              int tmp = x % 10;
              num *= 10;
              num += tmp;
              x /= 10;
          }
          return num;
      }
  };
  ```

  # 整数反转-wk

- 问题描述

  > 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
  >
  > 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
  >
  > 假设环境不允许存储 64 位整数（有符号或无符号）。

- 问题分析

  - 统一变为正数处理
  - 考虑数字越界问题，最简单的办法就是用long类型变量存储翻转值

- 问题代码

```java
class Solution {
    public int reverse(int x) {
        long res = 0;
        long tmp = x;
        boolean flag = true;
        if (x < 0) {
            flag = false;
            tmp = -tmp;
        }
        while(tmp > 0){
            res = res*10 + tmp%10;
            tmp/=10;
            if(res > Integer.MAX_VALUE) return 0;
            else if(flag&&res >= Integer.MAX_VALUE) return 0;
        }
        int res1 = flag?(int)res:(int)-res;
        return  res1;
    }
}
```

