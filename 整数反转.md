# 整数反转

- 问题描述

  给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

  如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

  假设环境不允许存储 64 位整数（有符号或无符号）。

  

- 问题分析

  反转整数的要点在于：获取这个整数的末尾数字，即可以通过模运算得到，接着再每次将该数除以10。由于整数可能为正也可能为负，因此循环的条件应设为：x != 0。

  本题的难点在于反转后溢出的判断，最大的整数为：2147283647，最小的整数为：-2147483648；可知，当反转的整数达到“214728365”时，若其仍未跳出循环，则必然大于最大整数；同理，当反转的整数达到“-214728365”时，若其仍未跳出循环，则必然小于最小整数；而由于如果原始整数的位数刚好等于最大整数的位数，其初始为只能为1或者2，必定小于7，因此判断是否溢出最大整数可设为：“num > INT_MAX/10”而最小整数可设为“num < INT_MIN/10”

  

- 问题解答

  ```c++
  class Solution {
  public:
      int reverse(int x) {
          int num = 0;
          while (x != 0) {
              if (num > INT_MAX/10 || num < INT_MIN/10)
                  return 0;
              int tmp = x % 10;
              num *= 10;
              num += tmp;
              x /= 10;
          }
          return num;
      }
  };
  ```

  

