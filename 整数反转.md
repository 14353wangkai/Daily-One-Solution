# 整数反转

- 问题描述

  给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

  如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

  假设环境不允许存储 64 位整数（有符号或无符号）。

  

- 问题分析

  反转整数的要点在于：获取这个整数的末尾数字，即可以通过模运算得到，接着再每次将该数除以10。由于整数可能为正也可能为负，因此循环的条件应设为：x != 0。

  本题的难点在于反转后溢出的判断，最大的整数为：2147283647，最小的整数为：-2147483648；可知，当反转的整数达到“214728365”时，若其仍未跳出循环，则必然大于最大整数；同理，当反转的整数达到“-214728365”时，若其仍未跳出循环，则必然小于最小整数；而由于如果原始整数的位数刚好等于最大整数的位数，其初始为只能为1或者2，必定小于7，因此判断是否溢出最大整数可设为：“num > INT_MAX/10”而最小整数可设为“num < INT_MIN/10”

  

- 问题解答

  ```c++
  class Solution {
  public:
      int reverse(int x) {
          int num = 0;
          while (x != 0) {
              if (num > INT_MAX/10 || num < INT_MIN/10)
                  return 0;
              int tmp = x % 10;
              num *= 10;
              num += tmp;
              x /= 10;
          }
          return num;
      }
  };
  ```

# 整数反转-wk

- 问题描述

  > 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
  >
  > 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31  −  1] ，就返回 0。
  >
  > 假设环境不允许存储 64 位整数（有符号或无符号）。

- 问题分析

  - 翻转操作很容易，就是将后面的数字通过模10取出来，通过乘10放到前面。
  - 环境只能使用32位整数，那么必须预先处理越界问题了
  - 这就导致一个问题，反转之后超过`2147483647`和`-2147483648`的数字是无法计算的，根据题意，遇到这类型的数字都要返回0。那么我们就要提前处理
  - 不难知道，`2147483647=2147483640+7`，`-2147483648=-2147483640-8`， 那么我们只要提前一个位置比较即可
  - 不过在比较前一个数字的时候，我们需要特别判断等于的情况，当一个数字的绝对值等于`214748364`的时候，
    - 对于正数，要判断下一位数字是否大于7
    - 对于负数，要判断下一位数字是否小于-8

- 问题代码

```java
class Solution {
    public int reverse(int x) { 
        int res = 0;
        int tmp = x;
        int max = Integer.MAX_VALUE / 10;
        int min = Integer.MIN_VALUE / 10;
        boolean flag0 = false;
        boolean flag1 = false;
        while (tmp != 0) {
            if (res >= max) {
                if (res > max) return 0;
                else flag0 = true;
            } 
            if (res <= min){
                if (res < min) return 0;
                else flag1 = true;
            }
            int residue = tmp % 10; 
            if (flag0 && residue > 7) return 0;
            if (flag1 && residue < -8) return 0;
             
            res = res * 10 + tmp % 10;
            tmp /= 10;
            
        }
        return res;
    }
}
```
