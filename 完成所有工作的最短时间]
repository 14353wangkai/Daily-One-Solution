

# [1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)-wk

- 问题描述

  >给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。
  >
  >请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。
  >
  >返回分配方案中尽可能 最小 的 最大工作时间

- 问题分析

  - 在B站看到一个状态压缩解法，时间复杂度很高，但是能过

  - 已知工作最多有12个，那么工作组合最多就是`2^12 = 4096`种状态

  - 我们要知道k个人完成`jobs`个工作的时候，承担最多工作量的工人，最少要花多少时间

    - 根据这个条件，状态可以由`工人数量`，`工作组合`两种
    - `dp[i][state]`：只用i个工人，完成一定数量的工作，承担最多工作量的工人需要的最小时间花销
    - `dp[i][state] = min(dp[i][state], max(dp[i-1][state-subset], time[subset]))`

  - 一个非常好的子集遍历`tips`

    - 假设有一个集合，我们将里面拥有的项用二进制的形式表现出来，那么就可以得到一个整数，记录为`allSet`
    - 遍历`allSet`的所有子集的方法就是`subset=(subset-1)&allSet`

    ```java
    for (int subset = allSet; subset > 0; subset=(subset-1)&allSet) {
        operate(subset);
    }
    ```

    

- 问题代码

```java
class Solution {
    public int minimumTimeRequired(int[] jobs, int k) {
        int [][]dp = new int[13][4096];
        int []time = new int[4096];
        int n = jobs.length;
        // 所有可能的工作分配
        for (int state = 0; state < (1 << n); ++state ) {
            int sum = 0; 
            for (int j = 0 ; j < n; ++j) {
                if (((state >> j) & 1) == 1) {
                    time[state] += jobs[j];
                }
            }
        }

        for (int state = 1; state < ( 1<<n) ; ++state) {
            dp[0][state] = Integer.MAX_VALUE;
        }
        dp[0][0] = 0;

        for (int i = 1; i <= k; ++i) {
            for (int state = 0; state < (1 << n); ++state) {
                dp[i][state] = Integer.MAX_VALUE; 
                // 遍历每一种子集
                for (int subset = state; subset > 0 ; subset=(subset-1)&state) {
                    dp[i][state] = Math.min(dp[i][state], Math.max(dp[i-1][state-subset], time[subset]));
                }
            }
        }
        return dp[k][(1<<n)-1];
    }
}
```

